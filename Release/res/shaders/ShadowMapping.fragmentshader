#version 330 core

// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 Position_worldspace;
in vec3 Position_worldspace2;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec4 ShadowCoord;
in vec3 normal;

// This is the output data.
vec3 colourAsVec3;
layout(location = 0) out vec4 colour;

const int MAX_LIGHT_AMOUNT = 2;

uniform sampler2D myTextureSampler;
uniform samplerCube shadowMaps[MAX_LIGHT_AMOUNT];

uniform int numberOfLights;
uniform vec3 lightPositions[2];
uniform vec3 lightDirections[2];
uniform vec3 lightColours[2];
uniform float lightPowers[2];

float distanceToLightModifier = 0.1;
int PCFModifier = 10;
float PI  = 3.1415926;
float far = 100.0;
float shadowScalingFactor = 1;

vec2 poissonDisk[16] = vec2[](
   vec2(-0.94201624, -0.39906216), 
   vec2(0.94558609, -0.76890725), 
   vec2(-0.094184101, -0.92938870), 
   vec2(0.34495938, 0.29387760), 
   vec2(-0.91588581, 0.45771432), 
   vec2(-0.81544232, -0.87912464), 
   vec2(-0.38277543, 0.27676845), 
   vec2(0.97484398, 0.75648379), 
   vec2(0.44323325, -0.97511554), 
   vec2(0.53742981, -0.47373420), 
   vec2(-0.26496911, -0.41893023), 
   vec2(0.79197514, 0.19090188), 
   vec2(-0.24188840, 0.99706507), 
   vec2(-0.81409955, 0.91437590), 
   vec2(0.19984126, 0.78641367), 
   vec2(0.14383161, -0.14100790) 
);

// This calculates the shadow. It contains a few methods of making shadows look nicer,
// including the fixing of shadow acne and peter panning. It also includes percentage-closer
// filtering (PCF).
float shadowCalculation(vec3 positionInLightSpace, int whichLight) {
    vec3 fragToLight = positionInLightSpace - lightPositions[whichLight];
    float closestDepth = texture(shadowMaps[whichLight], fragToLight).z;
    closestDepth *= far * shadowScalingFactor;
    float currentDepth = length(fragToLight) * shadowScalingFactor;
    float bias = 0.05; 
	if (currentDepth > far) {
		return 0;
	}
    float shadow = currentDepth -  bias > closestDepth ? 1.0 : 0.0;
	/*if (closestDepth == closestDepth) {
		float wtf = closestDepth / far;
		colour = vec4(vec3(wtf, wtf, wtf), 1.0);
		return -1;
	} else {
		return -1;
	}*/
	// return closestDepth / far;
    return shadow;
}  

void main(){
	// Material properties
	vec3 MaterialDiffuseColor = texture(myTextureSampler, UV).rgb;
	vec3 MaterialAmbientColor = vec3(0.15, 0.15, 0.15) * MaterialDiffuseColor;
	vec3 MaterialSpecularColor = vec3(0.3, 0.3, 0.3);

	vec3 diffuseColours[lightPositions.length()], specularColours[lightPositions.length()];
	vec3 finalDiffuseColour, finalSpecularColour;
	
	float visibility = 1.0;

	// Fixed bias, or...

	// ...variable bias
	// float bias = 0.005*tan(acos(cosTheta));
	// bias = clamp(bias, 0,0.01);
	
	for (int j = 0; j < MAX_LIGHT_AMOUNT; j++){
		float shadow = shadowCalculation(Position_worldspace, j);
		visibility -= shadow;
	}
	
	for (int i = 0; i < numberOfLights; i++) {
		// Normal of the computed fragment, in camera space
		// vec3 n = normalize(Normal_cameraspace);
		vec3 n = normal;
		// Direction of the light (from the fragment to the light)
		// vec3 l = normalize(lightDirections[i]);
		vec3 l = normalize(lightPositions[i] - Position_worldspace);
		// vec3 l = normalize(Position_worldspace2 - lightPositions[i]);
		
		// Cosine of the angle between the normal and the light direction, 
		// clamped above 0
		//  - light is at the vertical of the triangle -> 1
		//  - light is perpendiular to the triangle -> 0
		//  - light is behind the triangle -> 0
		float cosTheta = clamp(dot(n, l), 0, 1);
		
		// Eye vector (towards the camera)
		vec3 E = normalize(EyeDirection_cameraspace);

		// Direction in which the triangle reflects the light
		vec3 R = reflect(-l,n);

		// Cosine of the angle between the Eye vector and the Reflect vector,
		// clamped to 0
		//  - Looking into the reflection -> 1
		//  - Looking elsewhere -> < 1
		float cosAlpha = clamp(dot(E,R), 0,1);
		
		float distanceBetweenLightAndFragment = distance(Position_worldspace, lightPositions[i]);
		
		diffuseColours[i] = MaterialDiffuseColor * lightColours[i] * lightPowers[i] * cosTheta * ((1 / distanceBetweenLightAndFragment) / distanceToLightModifier);
		specularColours[i] = MaterialSpecularColor * lightColours[i] * lightPowers[i] * pow(cosAlpha, 2);
		visibility += cosTheta * lightPowers[i];
	}
	
	clamp(visibility, 0, 1);
	
	for (int i = 0; i < diffuseColours.length(); i++) {
		finalDiffuseColour += diffuseColours[i];
		finalSpecularColour += specularColours[i];
	}
	
	clamp(finalDiffuseColour, 0.0, 1.0);
	clamp(finalSpecularColour, 0.0, 1.0);

	// For spot lights, use either one of these lines instead.
	// if (texture(shadowMap, (ShadowCoord.xy/ShadowCoord.w)).z  <  (ShadowCoord.z-bias)/ShadowCoord.w)
	// if (textureProj(shadowMap, ShadowCoord.xyw).z  <  (ShadowCoord.z-bias)/ShadowCoord.w)
	
	colourAsVec3 = 
		// Ambient : simulates indirect lighting
		MaterialAmbientColor +
		// Diffuse : "colour" of the object
		visibility * finalDiffuseColour;
		
		// Screw specular colour right now. If you want it, do:
		// Specular : reflective highlight, like a mirror
		// + visibility * finalSpecularColour;
	colour = vec4(colourAsVec3, 1);
	// colour = vec4(visibility, visibility, visibility, visibility);
}